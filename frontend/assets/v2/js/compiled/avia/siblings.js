// Generated by CoffeeScript 1.3.3
var Sibling, Siblings,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Sibling = (function() {

  function Sibling(graphHeight, parent, price, delta, date, isActive) {
    var _this = this;
    this.graphHeight = graphHeight;
    this.parent = parent;
    this.price = price;
    this.delta = delta;
    if (isActive == null) {
      isActive = false;
    }
    this.rawDate = date;
    this.date = date.format('D');
    this.dow = date.format('dd');
    this.month = date.format('MMM');
    this.data = [];
    this.nodata = false;
    this.isActive = ko.observable(isActive);
    this.initialActive = isActive;
    this.scaledHeight = ko.computed(function() {
      var scale, spacing;
      spacing = 30;
      scale = _this.absDelta / (_this.graphHeight() - spacing);
      return _this.height / scale + spacing - 10;
    });
  }

  Sibling.prototype.columnValue = function() {
    if (this.initialActive) {
      return this.price;
    }
    return this.delta;
  };

  Sibling.prototype.background = function() {
    if (this.nodata) {
      this.graphHeight();
    }
    return "center " + this.scaledHeight() + "px";
  };

  return Sibling;

})();

Siblings = (function() {

  function Siblings(siblings, roundTrip, todayDate, rtTodayDate) {
    this.roundTrip = roundTrip;
    this.populate = __bind(this.populate, this);

    this.search = __bind(this.search, this);

    this.handleSearch = __bind(this.handleSearch, this);

    this.select = __bind(this.select, this);

    this.data = [];
    this.graphHeight = ko.observable(50);
    this.populate(this.data, siblings, todayDate, rtTodayDate);
    this.active = ko.observable(this.data[3]);
    this.selection = ko.observable({
      price: 0
    });
  }

  Siblings.prototype.select = function(sibling) {
    var entry, _i, _len, _ref;
    if (sibling.nodata) {
      return;
    }
    if (sibling.data.length) {
      this.active(sibling);
    } else {
      this.selection(sibling);
    }
    _ref = sibling.parent;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      entry = _ref[_i];
      entry.isActive(false);
    }
    return sibling.isActive(true);
  };

  Siblings.prototype.handleSearch = function(date, rtDate) {
    var app, panel;
    if (rtDate == null) {
      rtDate = false;
    }
    app = window.app;
    panel = app.fakoPanel();
    panel.sp.date(date.toDate());
    if (rtDate !== false) {
      panel.sp.rtDate(rtDate.toDate());
    }
    return app.navigate(panel.sp.getHash(), {
      trigger: true
    });
  };

  Siblings.prototype.search = function() {
    if (this.roundTrip) {
      this.handleSearch(this.active().rawDate, this.selection().rawDate);
      return;
    }
    return this.handleSearch(this.selection().rawDate);
  };

  Siblings.prototype.populate = function(root, siblings, todayDate, rtTodayDate) {
    var absDelta, date, index, isActive, item, maxPrice, minPrice, newsib, prevMonth, showMonth, sib, siblingPrice, todayPrice, _i, _j, _len, _len1, _results;
    todayPrice = siblings[3].price;
    for (index = _i = 0, _len = siblings.length; _i < _len; index = ++_i) {
      sib = siblings[index];
      siblingPrice = sib.price;
      date = todayDate.clone().subtract('days', 3 - index);
      showMonth = false;
      if (index === 0) {
        showMonth = true;
        prevMonth = date.month();
      }
      if (prevMonth !== date.month()) {
        showMonth = true;
        prevMonth = date.month();
      }
      if (index === 3) {
        isActive = true;
      } else {
        isActive = false;
      }
      newsib = new Sibling(this.graphHeight, root, siblingPrice, siblingPrice - todayPrice, date, isActive);
      if (sib.price === false) {
        newsib.nodata = true;
      }
      newsib.showMonth = showMonth;
      root.push(newsib);
      if (sib.siblings.length) {
        this.populate(newsib.data, sib.siblings, rtTodayDate);
      }
    }
    minPrice = _.min(root, function(item) {
      if (item.price === false) {
        return todayPrice;
      } else {
        return item.price;
      }
    });
    maxPrice = _.max(root, function(item) {
      if (item.price === false) {
        return todayPrice;
      } else {
        return item.price;
      }
    });
    if (minPrice.price === false) {
      minPrice = {
        price: todayPrice
      };
    }
    absDelta = maxPrice.price - minPrice.price;
    _results = [];
    for (_j = 0, _len1 = root.length; _j < _len1; _j++) {
      item = root[_j];
      item.height = maxPrice.price - item.price;
      _results.push(item.absDelta = absDelta);
    }
    return _results;
  };

  return Siblings;

})();
